
/////3446. Sort Matrix by Diagonals
//method- hash map (unordered_map) is used 
vector<vector<int>> sortMatrix(vector<vector<int>>& grid) {
        int n = grid.size();

        auto sortDiag = [&](int r, int c, bool asc) {
            vector<int> v;
            int i = r, j = c;
            while (i < n && j < n) { 
                v.push_back(grid[i][j]); 
                ++i;
                ++j; 
            }
            sort(v.begin(), v.end());
            if (!asc) {
                reverse(v.begin(), v.end());
            }   //descending
            i = r; j = c;
            int k = 0;
            while (i < n && j < n) {
                grid[i][j] = v[k++]; 
                ++i; 
                ++j; 
            }
        };

        // Bottom-left triangle (including main diagonal) -> descending
        for (int i = 0; i < n; ++i) {
            sortDiag(i, 0, false);
        }

        // Top-right triangle -> ascending (start from col=1 to skip main)
        for (int j = 1; j < n; ++j) {
            sortDiag(0, j, true);
        }

        return grid;
    }


    //method-2
    ///using priority_queue
    class Solution {
public:
    vector<vector<int>> sortMatrix(vector<vector<int>>& grid) {
        int n = grid.size(), m = grid[0].size();
        unordered_map<int, priority_queue<int>> maxHeaps;
        unordered_map<int, priority_queue<int, vector<int>, greater<int>>> minHeaps;

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                int key = i - j;
                if (key < 0) minHeaps[key].push(grid[i][j]);
                else maxHeaps[key].push(grid[i][j]);
            }
        }

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                int key = i - j;
                if (key < 0) {
                    grid[i][j] = minHeaps[key].top();
                    minHeaps[key].pop();
                } else {
                    grid[i][j] = maxHeaps[key].top();
                    maxHeaps[key].pop();
                }
            }
        }
        return grid;
    }
};